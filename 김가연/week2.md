## 도메인 모델과 테이블 모델
![](https://velog.velcdn.com/images/yeoni_/post/f9feb2bd-6695-4cea-a4b5-7c3fc7e1c01c/image.png)

### 임베디드 타입

최상위 레벨로 보면 JPA는 데이터 타입을 두 가지로 분류한다. 바로 **엔티티 타입**과 **값 타입**이다. 엔티티 타입은 우리가 구현할 때 `@Entity` 어노테이션을 붙여 정의하는 객체이다. 엔티티 내부의 모든 값들을 바꿔도 식별자만 유지되면 추적이 가능하다. 반면 값 타입은 int, Integer, String처럼 단순히 값으로 사용하는 자바 기본 타입이나 객체를 말한다. 식별자가 없고 값만 있으므로 변경시 추적 불가능하다. 임베디드 타입은 값 타입 중 하나이다. 주로 기본 값 타입을 모아서 만들기 때문에 복합 값 타입이라고도 한다. 

![](https://velog.velcdn.com/images/yeoni_/post/cc71aacc-240d-4e42-a0f3-7ca4697693ee/image.png)


위와 같은 테이블이 있다고 생각해보자. 회원 엔티티는 이름, 근무 시작일, 근무 종료일, 주소 도시, 주소 번지, 주소 우편번호를 가지고 있다. 그런데 테이블을 살펴보니 연관시켜서 한번에 관리하는 것이 더 수월하다는 생각이 든다. 즉,

- city, street, zipcode는 **주소**로 합칠 수 있을 것 같다.
- 근무 시작일, 근무 종료일은 **근무시간**으로 합칠 수 있을 것 같다.

![](https://velog.velcdn.com/images/yeoni_/post/bcd40fc8-00c4-4f38-8693-89d13a8103c3/image.png)

이런 식으로 회원 엔티티를 좀 더 추상화시킬 수 있다.

여기서 사용하는 Period와 Address가 바로 임베디드 타입이다. 임베디드 타입을 통해 연관된 속성들을 한번에 관리할 수 있어 응집도를 높일 수 있으며 다른 객체에서도 사용 할 수 있어 재사용성을 높힐 수 있다. 

위와 같이 임베디드 타입을 통해 객체를 분리하더라도 테이블은 하나만 매핑된다. 즉, 임베디드 타입을 사용하든 안하든 DB 테이블 입장에서는 변경되는 것이 없다는 말이다.


### 상속 관계 테이블 매핑 방법

![](https://velog.velcdn.com/images/yeoni_/post/aa639ecd-2c16-4390-8c1e-2ce13f708836/image.png)
해당 강의의 예제에는 옆과 같이 상속 관계의 객체들이 존재한다. 하지만 관계형 데이터베이스에는 상속 관계가 존재하지 않는다. 때문에 객체의 상속 구조와 DB의 슈퍼타입 서브타입 관계를 매핑하는 상속관계 매핑 작업이 필요하다.

    슈퍼타입과 서브타입이란? 

    슈퍼타입 : 상호 배타적인 더 작은 그룹으로 분할 시킬 수 있는 엔티티
    서브타입 : 슈퍼타입 내의 분해된 그룹
     

총 3가지의 방법이 있지만, 강의에서 사용하는 방식인 **단일 테이블 전략**에 대해서 알아보자.

![](https://velog.velcdn.com/images/yeoni_/post/4567d00b-ccf6-472c-896f-68f1ca343a3c/image.png)

**단일 테이블 전략**이란, 각각의 테이블로 나누는 것이 아닌, 하나의 통합된 테이블로 관리하는 전략이다. 

즉, 하나의 테이블로 관리하되 DTYPE 속성을 두어 구분하는 것이다. 

단일 테이블 전략은 모든 데이터를 하나의 테이블에서 관리하기 때문에 각각의 (자식)객체들을 구분할 수 있는 방법이 없다. 때문에 반드시 DTYPE을 두어 객체들을 분류할 수 있도록 해야한다.

단일 테이블 전략은 조인 쿼리가 나가지 않기 때문에 성능상의 이점이 있다. 때문에 서비스 규모가 크지 않고, 굳이 조인 전략을 선택해서 복잡하게 갈 필요가 없다고 판단 될 때에는 단일 테이블 전략도 하나의 선택사항이 될 수 있겠다.



### 연관관계의 주인

<aside>
⚠️ **외래 키가 있는 곳을 연관관계의 주인으로 정해라**

</aside>

**연관관계의 주인**이란, **양방향 매핑에서** 두 객체 중 **외래 키**를 누가 **관리하는 객체**를 말한다. 주인이 아닌 객체는 읽기만 가능하다. 즉, 연관관계의 주인은 단순히 외래 키를 누가 관리하느냐의 문제이기 때문에 비즈니스상 우위에 있다고 주인으로 설정해서는 안된다. 이때, 일대다 관계에서 **외래키는 항상 다쪽에 위치하도록 설계**해야 한다.

![](https://velog.velcdn.com/images/yeoni_/post/2039389b-dd86-4b6d-acf1-7b8ee4a72bcf/image.png)

만약, 위와 같은 연관관계가 존재한다고 가정해보자. 이때, Member(**多**)가 아닌 Team이 연관관계의 주인이 된다면 어떨까? 해당 팀에 소속된 member에 변경이 생기게 된다면 본인의 테이블인 Team이 아닌 다른 테이블 즉, Member 테이블에 Update 쿼리가 나가게 된다. 즉, Team 객체에 행위를 하였는데 다른 객체인 Member의 상태가 변하는 것이다. 이외에도 성능 문제 등, **연관관계의 주인은 외래키가 있는 객체**가 되어야 한다.